"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockProvider = void 0;
var eth_sig_util_1 = require("@metamask/eth-sig-util");
// eslint-disable-next-line import/prefer-default-export
var MockProvider = /** @class */ (function () {
    function MockProvider(setup) {
        var _this = this;
        this.isMetaMask = true;
        // eslint-disable-next-line no-console
        this.log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.setup.debug && console.log.apply(console, __spreadArray(['ðŸ¦„'], args, false));
        };
        this.setup = setup;
    }
    Object.defineProperty(MockProvider.prototype, "selectedAddress", {
        get: function () {
            return this.setup.address;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MockProvider.prototype, "networkVersion", {
        get: function () {
            return this.setup.networkVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MockProvider.prototype, "chainId", {
        get: function () {
            return "0x".concat(this.setup.networkVersion.toString(16));
        },
        enumerable: false,
        configurable: true
    });
    MockProvider.prototype.answerEnable = function (acceptance) {
        if (acceptance)
            this.acceptEnable('Accepted');
        else
            this.rejectEnable('User rejected');
    };
    MockProvider.prototype.request = function (_a) {
        var _this = this;
        var method = _a.method, params = _a.params;
        this.log("request[".concat(method, "]"));
        switch (method) {
            case 'eth_requestAccounts':
            case 'eth_accounts':
                if (this.setup.manualConfirmEnable) {
                    return new Promise(function (resolve, reject) {
                        _this.acceptEnable = resolve;
                        _this.rejectEnable = reject;
                    }).then(function () { return [_this.selectedAddress]; });
                }
                return Promise.resolve([this.selectedAddress]);
            case 'net_version':
                return Promise.resolve(this.setup.networkVersion);
            case 'eth_chainId':
                return Promise.resolve(this.chainId);
            case 'personal_sign': {
                var privateKey = Buffer.from(this.setup.privateKey, 'hex');
                var signed = (0, eth_sig_util_1.personalSign)({ privateKey: privateKey, data: params[0] });
                this.log('signed', signed);
                return Promise.resolve(signed);
            }
            case 'eth_sendTransaction': {
                return Promise.reject(new Error('This service can not send transactions.'));
            }
            case 'eth_decrypt': {
                this.log('eth_decrypt', { method: method, params: params });
                var stripped = params[0].substring(2);
                var buff = Buffer.from(stripped, 'hex');
                var encryptedData = JSON.parse(buff.toString('utf8'));
                var decrypted = (0, eth_sig_util_1.decrypt)({ encryptedData: encryptedData, privateKey: this.setup.privateKey });
                return Promise.resolve(decrypted);
            }
            default:
                this.log("resquesting missing method ".concat(method));
                // eslint-disable-next-line prefer-promise-reject-errors
                return Promise.reject("The method ".concat(method, " is not implemented by the mock provider."));
        }
    };
    MockProvider.prototype.sendAsync = function (props, cb) {
        switch (props.method) {
            case 'eth_accounts':
                cb(null, { result: [this.setup.address] });
                break;
            case 'net_version':
                cb(null, { result: this.setup.networkVersion });
                break;
            default: this.log("Method '".concat(props.method, "' is not supported yet."));
        }
    };
    MockProvider.prototype.on = function (props) {
        this.log('registering event:', props);
    };
    MockProvider.prototype.removeAllListeners = function () {
        this.log('removeAllListeners', null);
    };
    return MockProvider;
}());
exports.MockProvider = MockProvider;
//# sourceMappingURL=index.js.map